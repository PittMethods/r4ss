{
  "hash": "8d136433d96802146c6c87587e013ffa",
  "result": {
    "markdown": "---\nformat: \n  revealjs:\n    css: ../styles.css\n    slide-number: true\n    show-slide-number: all\n    preview-links: auto\n    self-contained: true\n    progress: true\n    history: true\n    hash-type: number\n    theme: default\n    code-block-background: true\n    highlight-style: zenburn\n    code-link: false\n    code-copy: true\n    pagetitle: \"R4SS Day 2A\"\n    author-meta: \"Jeffrey Girard\"\n    date-meta: \"2022-07-26\"\n---\n\n\n::: {.my-title}\n# [Introduction to R]{.blue} <br />for Social Scientists\n\n::: {.my-grey}\n[Workshop Day 2A | 2022-07-26]{}<br />\n[Jeffrey M. Girard | Pitt Methods]{}\n:::\n\n![](../img/proud_coder_357EDD.svg){.absolute bottom=0 right=0 width=400}\n:::\n\n<!-- Program II -->\n\n# Program II\n\n## Missing Values {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   Sometimes your data will have [missing values]{.b .blue}\n    -   Perhaps these were [never collected]{.b .green}\n    -   Perhaps the values were [lost/corrupted]{.b .green}\n    -   Perhaps the participant [didn't respond]{.b .green}\n\n::: {.fragment .mt1}\n-   We need to tell R which values are missing\n    -   To do so, we set those values to `NA`\n    -   Functions from **tidyverse** make this easy\n:::\n\n::: {.fragment .mt1}\n-   Missingness is often [\"contagious\"]{.b .green} in R<br />\n    e.g., a vector with `NA` has an unknown mean\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li rwotyanb trigger=loop delay=3000 speed=0.5 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## Missing Values Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse for the read and mutate functions\n\nlibrary(tidyverse)\n\n# ==============================================================================\n\n# PITFALL: Number codes for missingness will mess up calculations in R\n\nheights <- c(149, 158, -999) # here we use -999 to represent a missing value\n\nrange(heights)\n\nmean(heights)\n\nlog(heights) # our missing value is no longer -999\n\n# ==============================================================================\n\n# USECASE: Use NA for missingness instead\n\nheights2 <- c(149, 158, NA)\nheights2\n\nlog(heights2) # the NA stayed an NA (due to contagiousness)\n\n# ==============================================================================\n\n# LESSON: Use na.rm = TRUE to do a summary function ignoring the NAs\n\nmean(heights2) # the mean is an NA (due to contagiousness)\n\nmean(heights2, na.rm = TRUE)\n\nrange(heights2, na.rm = TRUE)\n\n# ==============================================================================\n\n# USECASE: Dealing with missing values in tibbles\n\ncereal <- read_csv(\"cereal.csv\")\n\ncereal$rating\n\nrange(cereal$rating)\n\n# ==============================================================================\n\n# LESSON: Use na_if() to convert specific values to NA while mutating\n\ncereal2 <- mutate(cereal, rating = na_if(rating, -999))\n\ncereal2$rating\n\nrange(cereal2$rating, na.rm = TRUE)\n\n# ==============================================================================\n\n# LESSON: Use read_csv(na) to convert specific values to NA while reading\n\ncereal3 <- read_csv(\"cereal.csv\", na = \"-999\")\n\ncereal3$rating\n\nrange(cereal3$rating, na.rm = TRUE)\n```\n:::\n\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## Factors {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   [Factors]{.b .blue} are used to represent categorical data\n    -   Factors have multiple possible [levels]{.b .blue}\n    -   Levels are [discrete]{.b .green} and mutually-exclusive\n\n::: {.fragment .mt1}\n-   Sometimes categories are [unordered]{.b .green} (nominal)\n    -   Action or Comedy or Drama\n    -   Asia or Europe or North America\n:::\n\n::: {.fragment .mt1}\n-   Sometimes categories are [ordered]{.b .green} (ordinal)\n    -   Mild < Medium < Hot\n    -   XS < S < M < L < XL\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li cdbgwqyw trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## Factors Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# USECASE: Ask 10 kids to order 1: nuggets, 2: pizza, or 3: salad\n\nfood <- c(2, 2, 1, 2, 1, 2, 1, 1, 2, 2)\nfood\n\n# ==============================================================================\n\n# LESSON: We can turn this vector into a factor with factor()\n\nfood2 <- factor(food, levels = c(1, 2, 3))\nfood2\n\nfood3 <- factor(food, levels = c(1, 2, 3),\n                labels = c(\"nuggets\", \"pizza\", \"salad\"))\nfood3\n\n# ==============================================================================\n\n# USECASE: We can also quickly and easily count each level with table()\n\ntable(food3)\n\n# ==============================================================================\n\n# PITFALL: Don't confuse levels and labels\n\nfood4 <- factor(food, labels = c(1, 2, 3),\n                levels = c(\"nuggets\", \"pizza\", \"salad\"))\nfood4 # full of <NA> because it can't find these levels\n\n# ==============================================================================\n\n# USECASE: You can also just enter strings directly (as self-labels)\n\ngenre <- c(\"pop\", \"metal\", \"pop\", \"rock\", \"rap\", \"rap\", \"pop\", \"rock\")\ngenre\n\ngenre2 <- factor(genre) # observed levels will be assigned alphabetically\ngenre2\n\ntable(genre2)\n\n# ==============================================================================\n\n# LESSON: If ordinal, enter levels low-to-high and add ordered = TRUE\n\nsalsa <- c(\"hot\", \"mild\", \"medium\", \"mild\", \"medium\", \"medium\")\n\nsalsa2 <- factor(salsa, \n                 levels = c(\"mild\", \"medium\", \"hot\"), \n                 ordered = TRUE)\nsalsa2 \n\n# NOTE: We may want to visualize or model ordinal factors differently\n\n# ==============================================================================\n\n# USECASE: Working with factors in a tibble\n\ncereal <- read_csv(\"cereal.csv\")\ncereal\n\ncereal2 <- mutate(cereal, mfr = factor(mfr), type = factor(type))\ncereal2\n\ntable(cereal2$mfr)\n\ntable(cereal2$type)\n```\n:::\n\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## String Manipulation {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   It can be helpful to [transform strings]{.b .blue}\n    -   Sometimes your [data]{.b .green} is text-based\n    -   Text also appears in [tables]{.b .green} and [figures]{.b .green}...\n    -   So we may want to customize it quickly\n\n::: {.fragment .mt1}\n-   Tidyverse contains tools for this\n    -   The functions all begin with `str_`\n    -   We will only discuss the basics\n    -   Learn more at [stringr.tidyverse.org](https://stringr.tidyverse.org/)\n:::\n\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li puvaffet trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## String Manipulation Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse for almost all of these functions\n\nlibrary(tidyverse)\n\n# ==============================================================================\n\n# USECASE: Re-capitalize strings\n\nx <- c(\"R4SS: Introduction to R for Social Scientists\")\n\nstr_to_lower(x)\n\nstr_to_upper(x)\n\nstr_to_sentence(x)\n\nstr_to_title(x)\n\n# ==============================================================================\n\n# USECASE: Extract subsets of strings\n\nx <- c(\"Apple\", \"Banana\", \"Pear\")\n\nstr_sub(x, start = 1, end = 3)\n\nstr_sub(x, start = -3, end = -1)\n\nstr_sub(x, start = 2, end = -2)\n\nstr_sub(x, start = 1, end = 5) # can go beyond the end\n\n# ==============================================================================\n\n# USECASE: Remove whitespace from strings\n\nx <- \"  Sometimes strings have   too   much white space \"\nx\n\nstr_trim(x) # remove white space at the start and end\n\nstr_squish(x) # trim and then collapse inner white space\n\n# ==============================================================================\n\n# USECASE: Remove and replace patterns in strings\n\nx <- \"Scientists very often utilize very fancy words, \n      even when they could utilize simpler ones.\"\n\nstr_remove(x, pattern = \"very \") # removes first pattern match only\n\nstr_remove_all(x, pattern = \"very \") # removes all pattern matches\n\nstr_replace(x, pattern = \"utilize\", replacement = \"use\")\n\nstr_replace_all(x, pattern = \"utilize\", replacement = \"use\")\n\n# NOTE: More complex patterns can be found using regular expressions (regex)\n\n# ==============================================================================\n\n# USECASE: Create a string manipulation pipeline\n\nx_clean <- \n  x |> \n  str_remove_all(\"very \") |> \n  str_replace_all(\"utilize\", \"use\") |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## If Else {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   A [locked door]{.b .green} behaves [conditionally]{.b .blue}\n    -   If you have the key, then open up...\n    -   Otherwise, stay closed...\n\n::: {.fragment .mt1}\n-   Sometimes we want [code]{.b .blue} to behave conditionally\n    -   *Filter* retains observations conditionally<br />\n        (e.g., if it meets a condition, it gets to stay)\n    -   Let's learn to [transform]{.b .green} variables conditionally\n    -   We can use `if_else()` for simple examples\n:::\n\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li efoxgafi trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## If Else Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse for almost all of these functions\n\nlibrary(tidyverse)\n\n# ==============================================================================\n\n# USECASE: Determining whether someone can vote in the US\n\nage <- 12\n\nage_group <- \n  if_else(\n    condition = age >= 18,\n    true = \"adult\",\n    false = \"child\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# TIP: Because argument names are optional, we can shorten this (if we want)\n\nage_group <- if_else(age >= 18, \"adult\", \"child\") |> print()\n\n# ==============================================================================\n\n# LESSON: This function is particularly useful applied to vectors\n\nages <- c(13, 18, 14, 19, 22, 16)\n\nage_groups <- if_else(ages >= 18, \"adult\", \"child\") |> print()\n\n# ==============================================================================\n\n# USECASE: We can therefore use it during data wrangling\n\ncereal <- read_csv(\"cereal.csv\", na = \"-999\")\n\ncereal2 <- mutate(cereal, popular = if_else(rating > 50, \"yes\", \"no\"))\ncereal2\n\ncereal3 <- \n  cereal |>\n  mutate(\n    diabetes = if_else(\n      condition = sugars == 0, \n      true = \"sugar-free\", \n      false = \"contains sugar\"\n    )\n  ) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## Case When {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   An [elevator]{.b .green} also behaves [conditionally]{.b .blue}\n    -   If you press a button, then it goes to that floor\n    -   There are usually more than just two buttons\n    -   In this analogy (but not in real life), the elevator only responds to the [first]{.b .green} button pressed\n\n::: {.fragment .mt1}\n-   Sometimes we want [code]{.b .blue} to behave this way\n    -   `case_when()` expands upon `if_else()`\n    -   It can have [multiple conditions]{.b .blue} (floor buttons)\n    -   The first condition met \"wins\" (picks the floor)\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li nwyovgla trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Program II\n:::\n\n## Case When Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse for almost all of these functions\n\nlibrary(tidyverse)\n\n# ==============================================================================\n\n# USECASE: Determine what types of movies your kids can watch\n\nages <- c(11, 13, 18)\n\nmovies_allowed <- \n  case_when(\n    ages >= 17 ~ \"R\",\n    ages >= 13 ~ \"PG-13\",\n    ages < 13 ~ \"PG\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# PITFALL: Don't put the least restrictive condition first\n\nage <- 18\n\nmovies_allowed2 <- \n  case_when(\n    age < 13 ~ \"PG\",\n    age >= 13 ~ \"PG-13\",\n    age >= 17 ~ \"R\"\n  ) |> \n  print() # age >= 13, so PG-13 wins before checking if age >= 17\n\n# ==============================================================================\n\n# USECASE: Use case_when to re-code variables during data wrangling\n\nstarwars\n\nsw <- \n  starwars |> \n  mutate(\n    species3 = case_when(\n      species == \"Human\" ~ \"Human\",\n      species == \"Droid\" ~ \"Droid\",\n      species != \"Human\" & species != \"Droid\" ~ \"Alien\"\n    )\n  ) |> \n  select(name, species3) |> \n  print()\n\n# ==============================================================================\n\n# TIP: The next version of case_when() will add the .default argument\n# This is where the elevator will drop you off if you hit no buttons\n\nsw <- \n  starwars |> \n  mutate(\n    species3 = case_when(\n      species == \"Human\" ~ \"Human\",\n      species == \"Droid\" ~ \"Droid\",\n      .default = \"Alien\"\n    )\n  ) |> \n  select(name, species3) |> \n  print()\n\n# NOTE: The above code won't work now, but it should in a few weeks/months\n# For now, you can use TRUE ~ \"Alien\" and it works but is harder to explain\n```\n:::\n\n\n::: footer\n\\[2A\\] Program II\n:::\n\n<!-- Wrangle III -->\n\n# Wrangle III\n\n## Summarize {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   Although we store data about many observations...\n-   ...we often want to [summarize across]{.b .blue} observations\n    -   This is like [folding]{.b .green} the tibble down to [one row]{.b .green}\n\n::: {.fragment .mt1}\n-   We've seen functions that summarize vectors\n    -   `length()`, `sum()`, `min()`, `max()`\n    -   `mean()`, `median()`, `sd()`, `var()`\n:::\n\n::: {.fragment .mt1}\n-   `summarize()` lets us use them on tibbles\n    -   It works very similarly to `mutate()`\n    -   It always creates a tibble as output\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li uhmqrsgl trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Summarize the typical sales\n\nmy_summary <- \n  sales |> \n  summarize(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# PITFALL: Don't use summary() instead of summarize()\n\nmy_summary <- \n  sales |> \n  summary(\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Use more than one summary function\n\nmy_summary <- \n  sales |> \n  summarize(\n    total_items = sum(items),\n    total_spent = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Use counting functions\n\nmy_counts <- \n  sales |> \n  summarize(\n    n_sales = n(),\n    n_customers = n_distinct(customer),\n    n_stores = n_distinct(store)\n  ) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Group Summarize {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n- We can also summarize a tibble [by group]{.b .blue}\n    -   This is like [folding]{.b .green} the tibble multiple times\n    -   Specifically, we fold down to [one row per group]{.b .green}\n\n::: {.fragment .mt1}\n-   The syntax for summarize is identical\n    -   The only difference is to the tibble\n    -   We first pass it through `group_by()`\n    -   Pipelines make this very easy\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li pmwtbpap trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Group Summarize Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nsales <- \n  tibble(\n    customer = c(1, 2, 3, 1, 3),\n    store = c(\"A\", \"A\", \"A\", \"B\", \"B\"),\n    items = c(25, 20, 16, 10, 5),\n    spent = c(685, 590, 392, 185, 123)\n  ) |> \n  print()\n\n# ==============================================================================\n\n# LESSON: We pass a tibble through group_by to group it\n\nsales\n\nsales |> group_by(store) # note the display says \"grouped\"\n\n# ==============================================================================\n\n# USECASE: We can then summarize and get stats per group\n\nsales |> \n  group_by(store) |> \n  summarize(\n    customers = n_distinct(customer),\n    items_sold = sum(items),\n    total_sales = sum(spent),\n    avg_items = mean(items),\n    avg_spent = mean(spent)\n  )\n\n# ==============================================================================\n\n# SETUP: Let's get a larger, more realistic dataset\n\n# Extra pane > Packages tab > Install > nycflights13\n\nlibrary(\"nycflights13\")\n\nflights\n\n# ==============================================================================\n\n# USECASE: Find the carrier with the lowest average delays\n\nflights |> \n  group_by(carrier) |> \n  summarize(m_delay = mean(dep_delay, na.rm = TRUE)) |> \n  arrange(m_delay)\n\n# ==============================================================================\n\n# LESSON: We can also group by multiple variables\n\n# USECASE: Let's find the day of the year with the most flights\n\nflights |> \n  group_by(month, day) |> \n  summarize(n_flights = n()) |> \n  arrange(desc(n_flights))\n\n# ==============================================================================\n\n# PITFALL: Note how this differs from grouping by just day\n\nflights |> \n  group_by(day)|> \n  summarize(n_flights = n()) |> \n  arrange(desc(n_flights))\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Across {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   We can use `across()` to [repeat an operation]{.b .blue} across multiple variables in a tibble\n    -   This makes our code [shorter]{.b .green}\n    -   It is [faster]{.b .green} to read and write\n    -   It is also [less error-prone]{.b .green}\n\n::: {.fragment .mt1}\n-   So we can repeat a function in order to...\n    -   ...`mutate()` multiple variables\n    -   ...`summarize()` multiple variables\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li iectdupg trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n## Across Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\nstarwars\n\n# ==============================================================================\n\n# USECASE: Applying the same mutation to multiple variables is a pain\n\nsw <- \n  starwars |> \n  mutate(\n    hair_color = factor(hair_color),\n    skin_color = factor(skin_color),\n    eye_color = factor(eye_color)\n  ) |> \n  print() # before\n\nsw <- \n  starwars |> \n  mutate(\n    across(\n      .cols = c(hair_color, skin_color, eye_color), \n      .fns = factor\n    )\n  ) |> \n  print() #after\n\n# ==============================================================================\n\n# PITFALL: Don't forget to wrap the .cols part in c()\n\nsw <- \n  starwars |> \n  mutate(\n    across(\n      .cols = mass, birth_year, \n      .fns = round,\n      digits = 1\n    )\n  ) |> \n  print() # error\n\n# ==============================================================================\n\n# LESSON: To pass arguments to the inner function, add them inside across()\n\nsw <- \n  starwars |> \n  mutate(\n    across(\n      .cols = c(mass, birth_year), \n      .fns = round,\n      digits = 1\n    )\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: You can also apply the same summary functions across variables\n\nsw <- \n  starwars |> \n  summarize(\n    height = mean(height, na.rm = TRUE),\n    mass = mean(mass, na.rm = TRUE),\n    birth_year = mean(birth_year, na.rm = TRUE)\n  ) |> \n  print()\n\nsw <- \n  starwars |> \n  summarize(\n    across(\n      .cols = c(height, mass, birth_year), \n      .fns = mean, \n      na.rm = TRUE\n    )\n  ) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Separate and Unite {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   Tidy data needs one value per cell\n\n::: {.fragment .mt1}\n-   So we may need to [separate]{.b .blue} cells\n    -   *e.g., What was the model of my first car?*\n    -   `\"Nissan Altima 2003\"` ⬎\n    -   `\"Nissan\"` `\"Altima\"` `\"2003\"`\n:::\n\n::: {.fragment .mt1}\n-   But some tasks require us to [unite]{.b .blue} cells\n    -   *e.g., What address should I mail to?*\n    -   `123` `\"Main Street\"` ⬎\n    -   `\"123 Main Street\"`\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li dsfanfaz trigger=loop delay=3000 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Separate Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\n# Create some example data\ndat <- \n  tibble(\n    id = c(\"A_001_01\", \"A_002_01\", \"B_001_01\", \"B_002_01\", \"C_001_01\", \"C_002_01\"),\n    duration = c(\"01:16\", \"01:21\", \"01:49\", \"00:34\", \"00:32\", \"00:54\")\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Separate a column into multiple columns\n\ndat2 <- \n  dat |> \n  separate(\n    col = duration, \n    into = c(\"min\", \"sec\"), \n    sep = \":\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# USECASE: This also works with more than two \"into\" columns\n\ndat2 <- \n  dat |>  \n  separate(\n    col = id, \n    into = c(\"group\", \"subject\", \"time\"), \n    sep = \"_\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# TIP: To automatically convert strings into numbers, use convert\n\ndat2 <- \n  dat |> \n  separate(\n    col = id, \n    into = c(\"group\", \"subject\", \"time\"), \n    sep = \"_\", \n    convert = TRUE\n  ) |> \n  print()\n\n# ==============================================================================\n\n# PITFALL: Don't forget to close the \"into\" vector's parentheses\n\ndat2 <- \n  dat|> \n  separate(col = duration, into = c(\"min\", \"sec\", sep = \":\")) #error\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Unite Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset\n\nlibrary(tidyverse)\n\ndat2 <- \n  dat|> \n  separate(col = id, into = c(\"group\", \"subject\", \"time\"), sep = \"x\") |> \n  separate(col = duration, into = c(\"min\", \"sec\"), sep = \":\") |> \n  print()\n\n# ==============================================================================\n\n# USECASE: Unite multiple columns into one string\n\ndat3 <- \n  dat2 |> \n  unite(col = \"newid\", group, subject, time, sep = \"-\") |> \n  unite(col = \"duration\", min, sec, sep = \":\") |> \n  print()\n\n# ==============================================================================\n\n# LESSON: Retain the columns being united with remove = FALSE\n\ndat3 <- \n  dat2 |> \n  unite(col = \"newid\", group:time, sep = \"\", remove = FALSE) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Pivot Longer and Wider {.smaller}\n\n::: {.columns .pv4}\n::: {.column width=\"60%\"}\n-   Both long and wide formats can be tidy\n    -   Long formats are better for MLM\n    -   Wide formats are better for SEM\n\n::: {.fragment .mt1}\n-   It can be useful to quickly [reshape a tibble]{.b .blue}\n    -   `pivot_longer()`: wide → long\n    -   `pivot_wider()`: long → wide\n:::\n:::\n\n::: {.column .tc .pv5 width=\"40%\"}\n\n{{< li xacejjis trigger=loop delay=3000 speed=0.5 colors=secondary:#2a76dd class=rc >}}\n\n\n:::\n:::\n\n## Pivot Longer Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset (from workshop website)\n\nlibrary(tidyverse)\n\ngradebook <- \n  read_csv(\"gradebook.csv\") |> \n  print()\n\n# ==============================================================================\n\n# USECASE: We can pivot to long format by creating name and value variables\n\ngradebook2 <- \n  gradebook |> \n  pivot_longer(\n    cols = c(test1, test2, test3, test4, test5), \n    names_to = \"test\", \n    values_to = \"grade\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# TIP: Use selection helpers to select columns quickly\n\ngradebook2 <- \n  gradebook |> \n  pivot_longer(\n    cols = test1:test5, \n    names_to = \"test\", \n    values_to = \"grade\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# LESSON: Automatically remove the name prefix\n\ngradebook2 <- \n  gradebook|> \n  pivot_longer(\n    cols = starts_with(\"test\"), \n    names_to = \"test\", \n    values_to = \"grade\",\n    names_prefix = \"test\"\n  ) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n## Pivot Wider Live Coding\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"false\"}\n# SETUP: We will need tidyverse and an example dataset (from workshop website)\n\nlibrary(tidyverse)\n\ndiary <- read_csv(\"diary.csv\") |> print()\n\n# ==============================================================================\n\n# USECASE: Reshape this long format to a wider format\n\ndiary_scale <- \n  diary |> \n  pivot_wider(\n    names_from = \"scale\",\n    values_from = \"score\"\n  ) |> \n  print()\n\ndiary_day <- \n  diary |>  \n  pivot_wider(\n    names_from = \"day\",\n    values_from = \"score\"\n  ) |> \n  print()\n\n# NOTE: There are thus multiple possible wide formats (for different uses)\n\n# ==============================================================================\n\n# LESSON: We can add a prefix to each name to avoid numeric names\n\ndiary_data\n\ndiary_day <- \n  diary |> \n  pivot_wider(\n    names_from = \"day\",\n    values_from = \"score\",\n    names_prefix = \"day_\"\n  ) |> \n  print()\n\n# ==============================================================================\n\n# LESSON: We can also pivot on multiple columns at once\n\ndiary_double <- \n  diary |> \n  pivot_wider(\n    names_from = c(\"scale\", \"day\"),\n    values_from = \"score\"\n  ) |> \n  print()\n```\n:::\n\n\n::: footer\n\\[2A\\] Wrangle III\n:::\n\n<!-- Practice III -->\n\n# [Practice III](https://pittmethods.github.io/r4ss/Day_2/Day2A_Practice.html){preview-link=\"false\"}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n\r\n      // dispatch for htmlwidgets\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for reveal\r\n    if (window.Reveal) {\r\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\r\n        fireSlideChanged(event.previousSlide, event.currentSlide);\r\n      });\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}